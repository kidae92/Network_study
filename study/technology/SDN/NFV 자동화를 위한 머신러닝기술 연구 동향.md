1. 요약:
   초연결, 초고속, 초저지연을 목표로 하는 5G와 같은 네트워크는 기존의 하드웨어를 기반으로 한 구조에서 발전하는 데 한계가 있어, 이러한 한계점을 극복하기 위하여 소프트웨어적으로 프로그래밍이 가능한 SND과 NFV를 적용하려는 노력이 있다. SDN과 NFV를 적용함에 따라 이들을 자동으로 제어하기 위하여 머신러닝 기술을 기반으로 이들의 지능화를 시도하고 있으며 SDN과 NFV 환경에 머신러닝을 적용하는 연구가 활발하게 이루어지고 있다. SDN/NFV 환경에 머신러닝을 적용한 네트워크 관리 및 오케스트레이션에 대한 선행 연구를 요약 및 분석하고 선행 연구의 한계점과 한계점 극복을 위한 향후 연구 방향을 제시

2. 서론:
   본 논문에서는 SDN과 NFV 환경에서 머신러닝을 이용한 네트워크 관리 및 오케스트레이션 자동화에 대한 선행 연구를 요약하고 분석. SDN과 NFV 구조 및 특징/머신러닝의 정의와 머신러닝 알고리즘의 대표적인 유형/기존 선행 연구 논문들을 머신러닝을 적용한 목적에 따라 선행 연구를 나누어 요약/선행 연구의 한계점 및 향후 연구방향 제시/결론

---

3. SDN(Software Defined Networking) : 데이터 평면과 제어 평면을 분리하여 네트워크 장비에는 데이터 평면만 남겨 패킷의 전달에만 집중하도록하고, 제어 평면은 외부 서버와 같은 중앙 컨트롤러로 옮겨 패킷의 경로 결정만 담당하도록 하는 기술이다.

   ![SDN_architecture](../images/SDN_architecture.PNG)

이 때 분리된 평면 간의 통신을 위해 오픈소스 API를 사용한다. [그림참조]

SDN은 네트워크 장비에서 경로 결정 기능을 제거하였기 때문에 각 네트워크 장비의 부하가 감소하게 되고, 중앙 컨트롤러가 전체 네트워크의 정책을 결정하기 때문에 전체 네트워크에 동시에 같은 정책을 적용할 수 있어 네트워크 제어가 간편해진다는 장점이 있다. 또한 오픈소스 API의 사용으로 네트워크 장비 회사에 대한 의존성이 줄어들고 다양한 네트워크 소프트웨어 개발 및 이용이 가능하게 된다.

4. NFV(Network Function Virtualization) : NFV는 그림과 같이 네트워크 기능을 클라우드 등의 VM에 소프트웨어적으로 구현하는 기술.

   ![NFV_architecture](../images/NFV_architecture.PNG)

NFV는 전통적 네트워크와 달리 하드웨어의 구입 없이 사용자가 원하는 때에 원하는 네트워크 기능을 만들어서 사용할 수 있기 때문에 네트워크 상황이 변화하여 새로운 기능이 요구되어도 유연하게 대응 할 수 있다. 또한 VM 위에 구현한 네트워크 기능은 여러 사용자들이 공유하여 사용할 수 있고, 필요하지 않게 되면 언제든지 삭제가 가능하기 떄문에 자원의 활용 측면에서 효율적이다.
다시 말해 스위치나 라우터 등의 물리적 네트워크 장비 기능을 가상화하여 VM이나 Container, 또는 범용 프로세서를 탑재한 하드웨어에서 구동하는 방식. 이를 통해 소프트웨어적으로 라우팅, 병화벽, 로드밸런싱, WAN가속, 암호화 등의 네트워크 기능을 구현하거나 네트워크 상의 다양한 위치로 이동 가능.

---

5. 지도학습 : 입력 데이터와 그에 대한 출력 데이터를 포함하는 레이블이 있는 데이터를 사용하여 학습을 진행하는 방법. 학습데이터의 입력 데이터와 출력 데이터로 해당 시스템의 함수를 추론하여 새로운 입력이 들어왔을 때 해당 함수를 이용하여 대응하는 출력을 예측. 지도학습은 연속적인 출력 데이터에 대한 예측인 회귀 분석(regression)과 불연속적인 출력 데이터에 대한 예측인 분류(classification)로 나뉜다.

6. 비지도학습 : 입력 데이터만을 가지는 레이블이 없는 데이터를 이용하여 학습. 입력 데이터에 대해 어떠한 출력 데이터가 존재해야 하는지에 대한 학습이 불가능하기 때문에, 입력 데이터의 특성을 이용하여 비슷한 특성을 가진 데이터들끼리 무리 짓는 K-means등과 같은 군집화(clustering) 알고리즘이 대표적

7. 강화학습 : 주어진 상황에서 어떤 행동을 취했을 때 받을 수 있는 보상이 최대가 되는지 계산하여 취해야 하는 최적의 행동을 에이전트가 스스로 학습해 나가는 방식. 행동에 대한 보상을 이용하여 미래에 받을 수 있는 보상의 평균을 최대화 하는 정책을 만드는 것이 강화학습의 목표. Q-러닝

8. 심층학습 : 인간의 두뇌를 모방하여 만든 인공신경망을 기반으로 다량의 데이터 속에서 특징을 추출하는 머신러닝 기법. 인공신경망은 입력계층과 출력계층을 그 사이의 은닉계층이 연결하는 형태를 이루는데, 여러 개의 은닉계층을 두어 결과를 도출하는 것이 심층학습. 지도,비지도 학습에 모두 이용될 수 있으며, 대표적으로 DBN(Deep Belied Network), CNN(Convolutional Neural Network), LSTM(Long Short-Term Memory)

## SDN/NFV 기반 네트워크 환경에서는 패킷을 일정 기준으로 나누는 것이 학습의 목적이 되는 경우가 많기 떄문에 네트워크는 분류 또는 군집화 알고리즘이 많이 사용된다. 네트워크에서 얻을 수 있는 데이터의 특성에 따라 지도학습이 가능한 경우에는 분류 알고리즘이, 지도학습이 불가능한 경우에는 군집화 알고리즘이 사용된다. 하지만 네트워크 관리 및 오케스트레이션은 목적이 다양하여 자원 할당과 같이 연속적인 값을 추론해야 하는 목적도 존재하기 때문에 회기 분석 알고리즘 역시 네트워크에 적용될 수 있다.

9. Flow : 패킷을 처리해주는 규칙의 단위.
   ex) 하나의 SDN Switch에서 Mac이 A인 패킷을 5번 포트로 보내고 싶다면 하나의 Flow가 생성된다. 다음으로 Mac이 B인 패킷을 6번 포트로 보내고 싶다면 또 하나의 Flow가 생성된다. 이렇게 생성된 Flow들은 스위치의 Flow Table에 저장된다. Flow는 Matching Field와 Action을 지정하여 생성하게 된다.
   ![Flow_Table](../images/Flow_Table.PNG)
   Matching Field에 들어 갈 수 있는 내용은 다음과 같다.
   ![Matching_Field](../images/Matching_Field.PNG)

   Action에 들어갈 수 있는 내용은 Drop 또는 특정 포트로 포워딩, 다른 테이블로 전달 등이 있다. 위의 Flow Table 그림을 Matching Field와 Action으로 쓴다면 아래와 같다.
   ![Field&Action](../images/Field&Action.PNG)

10. SDN Switch : SDN Switch는 하드웨어/소프트웨어 Switch로 볼 수 있다.
    하드웨어 스위치는 EdgecorE, Quanta 등 여러 벤더에서 생산하고 소프트웨어 스위치는 대표적으로 OpenVSwitch가 있다. 하드웨어 스위치는 보통 TCAM이라는 메모리에 Flow Table을 저장하고 소프트웨어 스위치는 RAM에 저장한다. 스위치의 메모리가 한정적이기 때문에 Flow Table 관리를 하는 방법에 많은 연구가 필요.
    또한 스위치에 패킷이 도착하였을 때 Matching되는 Flow를 찾는 방법에도 여러가지가 존재.
    TCAM 같은 경우에는 one cycle로 한번에 Matching되는 Flow를 찾고 OpenCSwitch Tuple Space Search를 사용한다. Openflow Switch는 Hash기반/Wildcard 기반으로 Flow Table을 구성하는데 Hash기반은 패킷의 정보를 해시 함수에 넣어 해시값을 생성하고 해시값을 Key값으로 Flow를 저장.
    Wildcard 기반은 Wildcard를 사용하여 Flow를 저장한다.

11. Overlay network : 물리 네트워크 위에 성립되는 가상의 컴퓨터 네트워크. 오버레이 네트워크 안의 노드는 가상, 논리 링크로 연결될 수 있으며, 각 링크는 네트워크 안에서 많은 물리적 링크를 통하지만 물리적 링크를 고려하지 않는다. 예를 들면, P2P 네트워크는 오버레이 네트워크라고 할 수 있다. 이는 물리적으로 전달망을 고려하지 않고 peer 와 peer 간의 연결만을 고려하기 때문이다. 전화 접속 인터넷은 전화망 위의 오버레이이다.
